<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Oracle on 茄子的养殖场</title>
        <link>https://proben1.github.io/tags/oracle/</link>
        <description>Recent content in Oracle on 茄子的养殖场</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 20 Sep 2024 10:12:15 +0800</lastBuildDate><atom:link href="https://proben1.github.io/tags/oracle/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Oracle中的Connect、Session和Process</title>
        <link>https://proben1.github.io/2024/oracle%E4%B8%AD%E7%9A%84connectsession%E5%92%8Cprocess/</link>
        <pubDate>Fri, 20 Sep 2024 10:12:15 +0800</pubDate>
        
        <guid>https://proben1.github.io/2024/oracle%E4%B8%AD%E7%9A%84connectsession%E5%92%8Cprocess/</guid>
        <description>&lt;h3 id=&#34;省流&#34;&gt;省流
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;connects (连接)、sessions(会话)和pocesses(进程)的关系：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;connect(连接)：使用plsql连接到oracle后，就是建立了一个连接(一次logon)&lt;/li&gt;
&lt;li&gt;session(会话)：决定同时登陆到数据库的并发用户数(数据库层面)&lt;/li&gt;
&lt;li&gt;processes(进程):也决定同时登陆到数据库的并发用户数(操作系统层面)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;connects-和session&#34;&gt;&lt;strong&gt;connects 和session：&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;有A/B两个城市，需要从A运送白菜到B城&lt;/p&gt;
&lt;p&gt;我们先建设一条公路（connection）
然后运送白菜过去，包括准备白菜和运送白菜以及返回等一系列的动作（session）&lt;/p&gt;
&lt;p&gt;一条公路，可以运送0-n次白菜（session &amp;gt;= connection）
当然从A到B的公路也可能不只一条（connection &amp;gt;= 1）&lt;/p&gt;
&lt;p&gt;某一次运送白菜，可以在真正上路时才开通某一条道路（需要session时才建connection）
一次运送不会影响别的运送的状态（同一connection上的不同session之间互不影响）&lt;/p&gt;
&lt;p&gt;因此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个连接可以进行多次的会话&lt;/li&gt;
&lt;li&gt;一个会话可以不依赖于某个连接，甚至没有连接(当我准备好了，真正开始运送时再建立连接)&lt;/li&gt;
&lt;li&gt;一个会话不会影响别的会话&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;session和processes&#34;&gt;&lt;strong&gt;session和processes：&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;每个sqllogon称为一个连接（connection)，而每个连接，可以产生一个或多个会话，如果数据库运行在专用服务器方式，一个会话对应一个服务器进程（process)；如果数据库运行在共享服务器方式，一个服务器进程可以为多个会话服务。&lt;/p&gt;
&lt;p&gt;使用共享模式连接示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ORCL_1 =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(DESCRIPTION =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	(ADDRESS_LIST =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.142)(PORT = 1521))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	(CONNECT_DATA =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		(server = shared )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		(sid = orcl)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用专用服务器模式连接示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ORCL_1 =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(DESCRIPTION =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (ADDRESS_LIST =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.142)(PORT = 1521))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	(CONNECT_DATA =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		(server = dedicated )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           (sid = orcl)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;常用查询sql&#34;&gt;常用查询sql
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--允许最大进程数processes：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;select value from v$parameter where name = &amp;#39;processes&amp;#39; ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--当前已用进程数processes：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;select count(*) from v$process ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--最大允许会话数session：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;show parameter sessions
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--当前已用会话数session：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;select count(1) from v$session;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--查看连接数历史最大值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;select resource_name,MAX_UTILIZATION,LIMIT_VALUE from v$resource_limit where resource_name in (&amp;#39;processes&amp;#39;,&amp;#39;sessions&amp;#39;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;（MAX_UTILIZATION代表数据库自上次启动以来达到的最大值，LIMIT_VALUE代表设置的最大值）
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--查询某客户端连接数据库的session值：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;select * from v$session where terminal=&amp;#39;RUIFEI&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--查询某客户端连接数据库的process值：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;select * from v$process
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;where addr in
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(select paddr from v$session where terminal=&amp;#39;RUIFEI&amp;#39;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--如果是专用服务器方式连接，session和process是一样的。
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--查看当前数据库使用的模式：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;select count(*) from v$shared_server;(结果不为0，表示共享模式)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--当前活动的session
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SELECT S.USERNAME,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       S.SID,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       S.SERIAL#,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       S.INST_ID,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       S.EVENT,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       S.WAIT_CLASS,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       S.SQL_EXEC_START,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       S.LOGON_TIME,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       S.ACTION,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       SQ.SQL_TEXT
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  FROM GV$SESSION S, GV$SQLAREA SQ
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; WHERE S.STATUS = &amp;#39;ACTIVE&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   AND S.USERNAME IS NOT NULL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   AND S.SQL_ID = SQ.SQL_ID;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Oracle静默安装</title>
        <link>https://proben1.github.io/2024/oracle%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85/</link>
        <pubDate>Sat, 27 Jul 2024 15:59:23 +0800</pubDate>
        
        <guid>https://proben1.github.io/2024/oracle%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85/</guid>
        <description></description>
        </item>
        <item>
        <title>Oracle物理逻辑存储概念区分</title>
        <link>https://proben1.github.io/2024/oracle%E7%89%A9%E7%90%86%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/</link>
        <pubDate>Thu, 04 Jul 2024 10:54:43 +0800</pubDate>
        
        <guid>https://proben1.github.io/2024/oracle%E7%89%A9%E7%90%86%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/</guid>
        <description>&lt;h3 id=&#34;前言&#34;&gt;前言
&lt;/h3&gt;&lt;p&gt;在刚学习Oracle的时候，会接触的一个叫“表空间”的词，很容易被误认为“表”。实际上这是两个完全不同的概念，&lt;strong&gt;表空间&lt;/strong&gt;是Oracle里逻辑存储上最大的单位，”表“是关系型数据库存储和管理数据的一种结构，由行和列组成，每行代表一条记录，每列代表记录中的一个字段。“表”对应Oracle逻辑存储的&lt;strong&gt;段&lt;/strong&gt;，而且只是众多&lt;strong&gt;段&lt;/strong&gt;的一种。&lt;/p&gt;
&lt;p&gt;现在我们看一下，该如何去理解这些概念：实例（Instance）、表空间（Table space）、模式（Schema）、数据库对象、用户（Users）、段（segment）、区（extend）、块（block）、表（table）、列（column）、行（row）&lt;/p&gt;
&lt;h3 id=&#34;行列表&#34;&gt;行、列、表
&lt;/h3&gt;&lt;p&gt;在关系数据库中，&lt;strong&gt;表&lt;/strong&gt;（Table）是数据的主要组织单元。它是由一组命名的列和行组成，用于存储和组织数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列&lt;/strong&gt;（Column）是表中的一个字段，用于存储特定类型的数据。每个列都有一个名称和相应的数据类型。例如，一个包含学生信息的表可以有列如&amp;quot;学生编号&amp;quot;、&amp;ldquo;姓名&amp;quot;和&amp;quot;年龄&amp;quot;等，其中每个列分别存储学生的唯一编号、姓名和年龄数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行&lt;/strong&gt;（Row），也称为记录（Record），是表中的一个实例或一个数据行。每行由一组与该表的列相对应的值组成。例如，在上述的学生信息表中，每一行可以表示一个学生的具体信息，包括学生编号、姓名和年龄。&lt;/p&gt;
&lt;p&gt;简单来说：&lt;/p&gt;
&lt;p&gt;表是一个二维的数据结构，由行和列组成。
列是表中的一个字段，用于定义数据的类型和存储特定数据。
行是表中的一个记录或实例，包含一组值，每个值与相应列对应。&lt;/p&gt;
&lt;p&gt;就像这样：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;EmpId&lt;/th&gt;
&lt;th&gt;Lastname&lt;/th&gt;
&lt;th&gt;Firstname&lt;/th&gt;
&lt;th&gt;Salary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Smith&lt;/td&gt;
&lt;td&gt;Joe&lt;/td&gt;
&lt;td&gt;40000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Jones&lt;/td&gt;
&lt;td&gt;Mary&lt;/td&gt;
&lt;td&gt;50000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Johnson&lt;/td&gt;
&lt;td&gt;Cathy&lt;/td&gt;
&lt;td&gt;44000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;块区段表空间&#34;&gt;块、区、段、表空间
&lt;/h3&gt;&lt;p&gt;接下来是Oralce逻辑存储上的划分：&lt;/p&gt;
&lt;p&gt;首先我们清空大脑，想象数据库宏观上都要存储哪些东西。&lt;/p&gt;
&lt;p&gt;主要是数据文件和日志文件，是吧。&lt;/p&gt;
&lt;p&gt;接着想象，它们存储在磁盘上，是直接在磁盘上吗？不，数据库要做到管理数据，就必须要划分出一个最小的单元，这个单元就叫做&lt;strong&gt;块&lt;/strong&gt;。块是Oracle数据库中最小的逻辑单元，也是最小的I/O单元。&lt;/p&gt;
&lt;p&gt;块的大小可以是2KB、4KB、8KB（默认）、16KB、32KB等，这些大小必须是倍数增加。&lt;/p&gt;
&lt;p&gt;一个块的结构包括以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;块头（Block Header）&lt;/strong&gt;：存放块的基本信息，如块的物理地址、块所属的类型（数据段、索引段等）、事务槽（用于记录对块进行事务处理的信息）等。块头的大小不是固定的，但通常占用一定的空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表目录（Table Directory）&lt;/strong&gt;：如果块中存储的数据为表数据，则表目录中保存这个表的相关信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行目录（Row Directory）&lt;/strong&gt;：如果块中存储的数据为表数据，则行目录中保存数据行的相关信息，它是一个指针数组，指示了每一行在数据块中的物理位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行数据（Row Data）&lt;/strong&gt;：真正存放数据的区域，这部分空间已被使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空闲空间（Free Space）&lt;/strong&gt;：未使用的区域，用于新行的插入或者已经存在行的更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在，一些块在物理上连续地在一起，就组成了一个&lt;strong&gt;区&lt;/strong&gt;，&lt;strong&gt;区&lt;/strong&gt;的大小从一个块到2GB不等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区&lt;/strong&gt;的概念很容易理解，当很多相连或者不相连的区组合在一起，就变成了一个&lt;strong&gt;段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;段&lt;/strong&gt;是Oracle数据库中的分配单位，对象如表、索引等都是以&lt;strong&gt;段&lt;/strong&gt;为单位进行分配。当创建一个表时将创建一个表段，创建一个索引时就创建一个索引段。每一个消耗存储空间的对象最终被存储到一个段中。有回滚段、临时段、聚簇段、索引段等。&lt;/p&gt;
&lt;p&gt;我们上边所说的表，其实就是一个&lt;strong&gt;表段&lt;/strong&gt;，也可以说数据段。毫无疑问，表段是最主要的段，但其他段的作用也不可忽视。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/668619c7d9c307b7e9bc82e1.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/668619c7d9c307b7e9bc82e1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;继续向上延伸，引出&lt;strong&gt;表空间&lt;/strong&gt;的概念：&lt;strong&gt;表空间&lt;/strong&gt;是数据库中存储数据的逻辑容器，可以包含一个或多个数据文件(*.DBF)，DBF文件就可以肉眼（ls命令）看到啦！&lt;/p&gt;
&lt;p&gt;一个段只能属于一个表空间，并且只能存储在该表空间的数据文件中。虽然段属于一个表空间，但它可以跨越该表空间内的多个数据文件（*.DBF）。Oracle数据库会自动管理数据块和区的分配，以便将段分布在多个数据文件中，以提高性能和空间利用率。而一个区只能属于一个数据文件。&lt;/p&gt;
&lt;h3 id=&#34;模式用户&#34;&gt;模式、用户
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;模式&lt;/strong&gt;是数据库对象的逻辑集合。&lt;strong&gt;数据库对象&lt;/strong&gt;包括表，视图，同义词，约束、索引，序列，游标，触发器，函数，变量，（控制块，异常），存储过程，包。模式中的对象存储在表空间中，一个表空间可以包含多个模式中的对象，而一个模式中的对象也可以分布在多个表空间中。
&lt;strong&gt;用户&lt;/strong&gt;是指拥有数据库访问权限的实体，每个用户都对应一个模式（Schema）。当用户在Oracle数据库中创建时，通常会为其指定一个默认表空间。该表空间将作为用户创建新对象（如表、索引等）时的默认存储位置。
要注意，schema是逻辑对象的集合组织，是一个&lt;strong&gt;组织概念&lt;/strong&gt;，和表空间等&lt;strong&gt;逻辑概念&lt;/strong&gt;不属于一个层面。在oracle中，一个user对应的就是一个schema，二者是强相关的。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;p&gt;oracle数据库存储的逻辑和物理结构&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/668b474bd9c307b7e9278580.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/668b474bd9c307b7e9278580.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Oracle细节知识整理</title>
        <link>https://proben1.github.io/2024/oracle%E7%BB%86%E8%8A%82%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</link>
        <pubDate>Thu, 04 Jul 2024 09:44:37 +0800</pubDate>
        
        <guid>https://proben1.github.io/2024/oracle%E7%BB%86%E8%8A%82%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</guid>
        <description>&lt;h3 id=&#34;自动共享管理内存-asmm&#34;&gt;&lt;strong&gt;自动共享管理内存&lt;/strong&gt; ASMM
&lt;/h3&gt;&lt;p&gt;从 Oracle 10g 开始，Oracle 提供了自动 SGA 的管理（简称 ASMM，Automatic Shared Memory Management）新特性。不再需要手工设置若干内存池的大小，而是为 SGA 设置一个总的大小尺寸即可。&lt;/p&gt;
&lt;p&gt;原理：Oracle 新引入了一个名为 MMAN（Memory Manager）的后台进程。每隔很短的一段时间，MMAN 进程就会启动，然后去询问一下 Oracle 提供的各个内存组件顾问，由这些顾问根据当前的负载情况，将可以自动调整的内存池建议的大小尺寸，返回给 MMAN。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MEMORY_TARGET&lt;/code&gt; 参数定义了整个 SGA 的总容量，不能超过&lt;code&gt;MEMORY_MAX_TARGET&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;statistics_level&lt;/code&gt; 必须设置为 typical 或 all 才能启动ASMM，否则如果设置为 basic，则关闭 ASMM。&lt;/p&gt;
&lt;p&gt;参数大小设置如下：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/6686006ad9c307b7e9925a91.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/6686006ad9c307b7e9925a91.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;关机指令&#34;&gt;关机指令
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SHUTDOWN NORMAL（普通关闭）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有指定任何模式，则默认使用NORMAL模式。&lt;/li&gt;
&lt;li&gt;在此模式下，Oracle服务器在完成关闭之前会&lt;strong&gt;等待所有用户断开连接&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;数据库高速缓冲区缓存和重做日志缓冲区被写入磁盘。&lt;/li&gt;
&lt;li&gt;终止后台进程，并从内存中删除SGA（系统全局区）。&lt;/li&gt;
&lt;li&gt;在关闭实例之前，Oracle服务器会关闭并卸除数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SHUTDOWN IMMEDIATE（立即关闭）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用此命令时，Oracle服务器&lt;strong&gt;不等待当前连接到数据库的用户&lt;/strong&gt;直接断开连接。&lt;/li&gt;
&lt;li&gt;Oracle服务器会&lt;strong&gt;回滚&lt;/strong&gt;活动事务并断开所有已连接用户的连接。&lt;/li&gt;
&lt;li&gt;在关闭实例之前，Oracle服务器会关闭并卸除数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SHUTDOWN TRANSACTIONAL（事务保证关闭）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在此模式下关闭可防止客户端丢失数据，包括其当前活动会话的结果。&lt;/li&gt;
&lt;li&gt;没有客户端可以在此实例上启动新事务。&lt;/li&gt;
&lt;li&gt;当客户端结束正在进行的事务时，客户端将断开连接。&lt;/li&gt;
&lt;li&gt;完成所有事务后，将立即关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SHUTDOWN ABORT（强制终止/强制关闭）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在某些紧急情况下，如果其他关闭模式均无效，可以使用此命令。&lt;/li&gt;
&lt;li&gt;Oracle服务器正在处理的当前SQL语句将立即终止。&lt;/li&gt;
&lt;li&gt;Oracle服务器不等待当前连接到数据库的用户直接断开连接。&lt;/li&gt;
&lt;li&gt;数据库高速缓冲区缓存和重做缓冲区&lt;strong&gt;未写入磁盘&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;未提交的事务&lt;strong&gt;不会回滚&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;该实例将终止而不关闭文件。&lt;/li&gt;
&lt;li&gt;数据库未关闭或卸载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;scope参数&#34;&gt;scope参数
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SCOPE&lt;/code&gt;参数在Oracle数据库中用于控制&lt;code&gt;ALTER SYSTEM&lt;/code&gt;命令对数据库参数修改的生效范围和时机，总共有三个值：BOTH、MEMORY，SPFILE。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MEMORY：仅对当前实例的内存中的参数值进行修改，不改变服务器参数文件（SPFILE）中的值，修改立即生效，但只持续到数据库实例关闭。&lt;/li&gt;
&lt;li&gt;SPFILE：仅对服务器参数文件（SPFILE）中的参数值进行修改，不改变当前实例的内存中的值。修改不会立即生效，而是在数据库实例下一次启动时生效。&lt;/li&gt;
&lt;li&gt;BOTH：同时修改当前实例的内存中的参数值和服务器参数文件（SPFILE）中的值。修改立即生效（针对内存中的值），并且在数据库实例下一次启动时仍然有效（因为SPFILE中的值也被修改了）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;asm实现高可用的方式&#34;&gt;ASM实现高可用的方式
&lt;/h3&gt;&lt;p&gt;ASM（Automatic Storage Management，自动存储管理）是Oracle推荐的一种智能化数据库文件存储管理方式，它通过自动管理磁盘组来平衡I/O负载，提高数据的可靠性和可用性。&lt;/p&gt;
&lt;p&gt;ASM提供三种镜像类型来实现数据冗余：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;外部冗余（External Redundancy）&lt;/strong&gt;：没有镜像的一种冗余方式，即在磁盘组中没有故障组。这种方式下，Oracle不管理镜像，镜像功能由外部存储系统实现（如RAID技术）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常规冗余（Normal Redundancy）&lt;/strong&gt;：要求磁盘组具有两个故障组，每个故障组一个磁盘控制器。这种方式下，Oracle提供两份镜像来保护数据，有效磁盘空间是所有磁盘设备大小之和的1/2。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高冗余（High Redundancy）&lt;/strong&gt;：要求磁盘组具有三个故障组，每个故障组一个磁盘控制器。这种方式下，Oracle提供三份镜像来保护数据，以提高性能和数据的安全性。有效磁盘空间是所有磁盘设备大小之和的1/3。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;block_size对应最大的表空间大小&#34;&gt;block_size对应最大的表空间大小
&lt;/h3&gt;&lt;p&gt;Oracle的Rowid使用22位来代表数据块号，因此Oracle表空间数据文件每个数据文件最多只能包含2^22个数据块。
也因此数据库表空间的数据文件不是无限增长的，例如：&lt;/p&gt;
&lt;p&gt;登DBA用户，查询当前ORACEL数据库数据库的大小：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SQL&amp;gt; select name,value from v$parameter where name = &amp;#39;db_block_size&amp;#39;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                           VALUE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;------------------------------ --------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;db_block_size                  8192
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在数据块为8k的情况下，单个数据文件的最大容量为8K*2^22 = 32G。&lt;/p&gt;
&lt;p&gt;因此，有的表空间扩容不能直接resize，需要去添加新的数据文件到表空间中，例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLESPACE TAB_CC ADD DATAFILE &#39;/oradata/test2.dbf&#39; SIZE 10G;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;oracle几种启动状态&#34;&gt;Oracle几种启动状态
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1、startup nomount；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　非安装启动，数据库实例已经启动，但并未加载任何数据库文件，因此不能访问数据库中的数据。此阶段通常用于新建数据库、修复控制文件等场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动实例&lt;/strong&gt;：数据库实例开始运行，但此时并不加载数据库文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化SGA&lt;/strong&gt;：系统全局区（SGA）被初始化，分配内存结构供实例使用。SGA包括数据库缓冲区缓存、日志缓冲区、共享池等关键内存结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动后台进程&lt;/strong&gt;：启动一系列必需的后台进程，如PMON（进程监控器）、SMON（系统监控器）、DBWn（数据库写入器）、LGWR（日志写入器）和CKPT（检查点进程）等，这些进程负责数据库的运行和维护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读取初始化文件&lt;/strong&gt;：读取并解析初始化文件（如init.ora或spfile），该文件包含数据库启动和运行所需的配置参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;打开警告日志和跟踪文件&lt;/strong&gt;：启动过程中，相关的警告日志和跟踪文件被打开，用于记录数据库的运行状态和错误信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2、startup mount (dbname)；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　安装启动，这种模式将启动实例，加载数据库并保持数据库关闭状态。这种方式启动下可执行：数据库日志归档、数据库介质恢复、使数据文件联机或脱机、重新定位数据文件、重做日志文件。&lt;/p&gt;
&lt;p&gt;　　此时我们可以查看数据字典，因为控制文件已经打开；不能访问数据库的数据文件（表，视图），此时数据文件没有打开。&lt;/p&gt;
&lt;p&gt;改变归档模式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;archive log list;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ALTER DATABASE ARCHIVELOG;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ALTER DATABASE NOARCHIVELOG;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;暂停和重开数据库&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ALTER SYSTEM SUSPEND;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ALTER SYSTEM RESUME;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（接上）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;打开控制文件&lt;/strong&gt;：控制文件是Oracle数据库的关键文件之一，它包含了数据库的物理结构信息，如数据文件、重做日志文件的位置和状态等。在MOUNT阶段，数据库会打开控制文件，并读取其中的信息，以确认数据文件和联机日志文件的位置和状态。但此时不会对数据文件和日志文件进行实际的读写操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;准备数据访问&lt;/strong&gt;：虽然MOUNT阶段不会直接打开数据文件，但数据库会确保控制文件中记录的数据文件和日志文件的位置是有效的，并准备在后续的OPEN阶段中打开这些文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记录日志信息&lt;/strong&gt;：如实例启动的详细信息、控制文件的打开情况等。这些日志信息对于数据库的故障排查和恢复非常重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3、startup open (dbname)；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ALTER DATABASE OPEN&lt;/code&gt;：从mount或nomount状态切换到open&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STARTUP&lt;/code&gt;：先执行“nomount”，然后执行“mount”，再打开包括Redo log文件在内的所有数据库文件，这种方式下可访问数据库中的数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;startup 等于以下三个命令
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;　　startup nomount；
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;　　alter database mount；
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;　　alter database open；
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看oracle 启动状态：&lt;/p&gt;
&lt;p&gt;&lt;code&gt; select status from v$instance； （showdown | nomount | mount | open）&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;oracle索引类型&#34;&gt;Oracle索引类型
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;b-tree索引
Oracle数据库中最常见的索引类型是b-tree索引，也就是B-树索引，以其同名的计算科学结构命名。CREATE
INDEX语句时，默认就是在创建b-tree索引。没有特别规定可用于任何情况。&lt;/li&gt;
&lt;li&gt;位图索引(bitmap index)
位图索引特定于该列只有几个枚举值的情况，比如性别字段，标示字段比如只有0和1的情况。&lt;/li&gt;
&lt;li&gt;基于函数的索引
比如经常对某个字段做查询的时候是带函数操作的，那么此时建一个函数索引就有价值了。&lt;/li&gt;
&lt;li&gt;分区索引和全局索引
这2个是用于分区表的时候。前者是分区内索引，后者是全表索引&lt;/li&gt;
&lt;li&gt;反向索引（REVERSE）
这个索引不常见，但是特定情况特别有效，比如一个varchar(5)位字段(员工编号)含值
（10001,10002,10033,10005,10016..）
这种情况默认索引分布过于密集，不能利用好服务器的并行
但是反向之后10001,20001,33001,50001,61001就有了一个很好的分布，能高效的利用好并行运算。&lt;/li&gt;
&lt;li&gt;HASH索引
HASH索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。集群键上不同值的数目必须在创建HASH集群之前就要知道。需要在创建HASH集群的时候指定这个值。使用HASH索引必须要使用HASH集群。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Oracle服务器结构</title>
        <link>https://proben1.github.io/2024/oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84/</link>
        <pubDate>Wed, 03 Jul 2024 14:48:43 +0800</pubDate>
        
        <guid>https://proben1.github.io/2024/oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h3 id=&#34;前言&#34;&gt;前言
&lt;/h3&gt;&lt;p&gt;在接触Oracle之前，寻思我都用过MySQL了，这玩意搞起来不是轻轻松松？事实上错得离谱啊。“用过”代表只是会一点SQL语句，也就是说我对数据库本身是未知的一个状态。&lt;/p&gt;
&lt;p&gt;MySQL是中小型、小内存的数据库，对于字符串可以使用双引号，并且在windows下大小写不敏感，Linux下敏感。&lt;/p&gt;
&lt;p&gt;Oracle是大型、大内存的数据库，对于字符串只可以单引号，普通情况下会将所有小写都转换为大写进行处理。&lt;/p&gt;
&lt;h3 id=&#34;oracle服务器&#34;&gt;Oracle服务器
&lt;/h3&gt;&lt;p&gt;Oracle服务器通常指的是运行Oracle数据库管理系统的硬件和软件环境的总称。它不仅仅是一个数据库管理系统（DBMS），还包括了运行DBMS所需的服务器硬件、操作系统、网络连接等。&lt;/p&gt;
&lt;p&gt;概述：Oracle服务器由Oracle数据库软件、数据库实例、监听器（Listener）、网络服务等部分组成。其中，Oracle数据库软件是核心，是一个具有高性能和高可靠面向对象&lt;strong&gt;关系型数据库管理系统（Relational Database Management System，RDBMS）&lt;/strong&gt;，负责数据库的管理和操作；数据库实例是数据库运行时在内存中的表示，包括内存结构和后台进程；监听器则负责监听客户端的连接请求，并将其转发给相应的数据库实例。&lt;/p&gt;
&lt;p&gt;在结构上，Oracle 服务器（Oracle Server）由实例（Instance）和数据库（Database）两大部分构成。实例是一组内存结构和 Oracle 后台进程的集合；数据库在物理上由多个操作系统文件组成，其中主要包括数据文件、控制文件和重做日志文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Oracle 服务器=实例+数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例（Instance） = 内存结构+ 后台进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存结构 = SGA （System Global Area）+ PGA（Program Global Area）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库 = 数据文件 + 控制文件 + 联机重做日志文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/668500eed9c307b7e9eea2ab.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/668500eed9c307b7e9eea2ab.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;oracle实例&#34;&gt;Oracle实例
&lt;/h3&gt;&lt;p&gt;实例是数据库运行时在内存中的表示，相当于用户和数据库的中间层。一个数据库可以有很多实例，而一个实例在生存周期中只能属于一个数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例（Instance） = 内存结构（System Global Area，SGA）+ 后台进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内存结构描述的是 Oracle 数据库对内存的使用构成，Oracle 内存结构总称为 &lt;strong&gt;SGA&lt;/strong&gt; 。包括数据库高速缓冲区、重做日志缓冲区和共享池等部分。&lt;/p&gt;
&lt;p&gt;后台进程有 DBWn、CKPT、LGWR、SMON、PMON、ARCn 、RECO等。&lt;/p&gt;
&lt;h3 id=&#34;oracle数据库&#34;&gt;Oracle数据库
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Oracle 数据库 = 数据文件 + 控制文件 + 联机重做日志文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除此之外，还有&lt;strong&gt;非数据库文件&lt;/strong&gt;如参数文件、口令文件、归档日志文件、跟踪文件、警告文件等。&lt;/p&gt;
&lt;h3 id=&#34;sga&#34;&gt;SGA
&lt;/h3&gt;&lt;h4 id=&#34;数据库高速缓冲区&#34;&gt;数据库高速缓冲区
&lt;/h4&gt;&lt;p&gt;数据库高速缓冲区的作用就是用来缓存最近从数据库中读出的数据块，并可供其他客户进程共享。用户进程查看数据时，首先检查需要的信息是否在缓冲区内，如果在缓冲区中，就可以直接访问，否则访问物理文件并读取数据块到数据库缓冲区。&lt;/p&gt;
&lt;p&gt;根据缓冲数据块的状态，Oracle 将数据高速缓冲区可划分成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏缓冲区（Dirty Buffer）：当数据库发生 DML（Insert、Update、Delete）操作时，会对缓冲区内容进行修改，这样缓冲区的内容就会和相对应的数据文件不一致，这时，缓冲区标识为“脏缓冲区”。&lt;/li&gt;
&lt;li&gt;自由缓冲区（Free Buffer）：当“脏缓冲区”的内容被写入数据文件后，因为该缓冲区与相应数据文件部分内容一致，所以将这些缓冲区称为“自由缓冲区”。&lt;/li&gt;
&lt;li&gt;忙缓冲区（Pinned Buffer）：指服务器进程正在访问的缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Oracle 用&lt;strong&gt;LRU&lt;/strong&gt;（Least Recently Used）算法来管理数据高速缓冲区。&lt;/p&gt;
&lt;h4 id=&#34;重做日志缓冲区&#34;&gt;重做日志缓冲区
&lt;/h4&gt;&lt;p&gt;重做日志缓冲区用来记录对数据缓冲区数据进行的修改。&lt;/p&gt;
&lt;p&gt;当用户运行DML(INSERT、UPDATE、DELETE)以及 DDL(CREATE、ALTER、DROP)语句时，会改变数据高速缓存中的相应缓冲区。但是在修改这些缓冲区之前，Oracle 会自动生成重做项，首先要将这些缓冲区的变化记载到“重做日志缓冲区”中。&lt;/p&gt;
&lt;p&gt;重做日志缓冲区由一条一条的重做项构成，每条重做项记载了修改的时间、被修改的块、修改位置以及新数据。缓冲区被循环使用，当重做日志缓冲区填满时，数据库系统将&lt;strong&gt;重做日志缓冲区&lt;/strong&gt;的内容写入&lt;strong&gt;日志文件&lt;/strong&gt;。在系统发生故障时，可以通过重做项重新执行对数据库的修改，实现对实例的恢复。&lt;/p&gt;
&lt;h4 id=&#34;共享池&#34;&gt;共享池
&lt;/h4&gt;&lt;p&gt;共享池（Shared Pool）内包含了库缓存（Library Cache），数据字典缓冲区（Dictionary Cache），并行执行消息缓冲区（Buffers for parallel execution messages），以及用于系统控制的各种内存结构。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/6685f58fd9c307b7e9835ab0.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/6685f58fd9c307b7e9835ab0.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据字典缓冲区&lt;/strong&gt;：数据字典被存放在 SYSTEM 表空间的数据文件中，是一系列保存了数据库重要参考信息（账户、数据文件、表的描述、用户权限等）的表和视图。执行任何 SQL 语句都需要访问数据字典。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;视图有三种实例：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user_*(当前用户所拥有对象的有关信息)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;all_*(当前用户可访问对象的信息)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dba_*(数据库中所有对象的信息)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如，当用户执行&amp;quot;SELECT * FROM emp WHERE empno=7788&amp;quot;语句时，Oracle 需要查询数据字典 dba_tables 确定表 emp 是否存在；如果该表已经存在，还需要查询数据字典dba_tab_columns 确定列 empno 在表 emp 中是否存在，然后才能生成执行语句的过程（执行计划）。这些定义在首次查询时存入数据字典高速缓冲区，在后续过程中用到就可以直接使用，而不必重新查询数据字典。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;库高速缓冲区&lt;/strong&gt;：又可分为&lt;strong&gt;共享 SQL 区&lt;/strong&gt;和共享 &lt;strong&gt;PL/SQL 区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享 SQL 区&lt;/strong&gt;用来存放最近执行的 SQL 语句信息，包括语句文本、解析树及执行计划，通过**上下文区(Context Area)**来实现。相同格式的SQL在解析时可以共享上下文区，减少解析次数，提升性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享PL/SQL区&lt;/strong&gt;用来存放最近执行的PL/SQL语句，解析和编译过的程序单元和过程（函数、包和触发器）也存放在此区域。&lt;/p&gt;
&lt;h4 id=&#34;大池&#34;&gt;大池
&lt;/h4&gt;&lt;p&gt;供一次性大量的内存分配使用，例如：&lt;/p&gt;
&lt;p&gt;● I/O 服务进程&lt;/p&gt;
&lt;p&gt;● Oracle 备份与恢复操作&lt;/p&gt;
&lt;p&gt;大池能够更好地满足此类大量内存分配的要求。&lt;/p&gt;
&lt;h4 id=&#34;java池和流池&#34;&gt;Java池和流池
&lt;/h4&gt;&lt;p&gt;Java 池供各会话内运行的 Java 代码及 JVM 内的数据使用。&lt;/p&gt;
&lt;p&gt;流池主要用于缓存流进程在数据库间移动或复制数据时使用的队列消息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;想象你有一个大的仓库（数据库），里面存着很多货物（数据）。现在，你想把这些货物（数据）快速地搬运到另一个仓库（可能是另一个数据库，或者是数据库内的另一个部分）去。Oracle流池就像是你在搬运过程中使用的一个临时存放区或者是一个快速通道。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;pga&#34;&gt;PGA
&lt;/h3&gt;&lt;p&gt;当客户进程访问 Oracle 服务器时，会在 Oracle 服务器端为用户进程分配相应的服务进程，并且为该服务进程分配相应的内存空间来存放其数据和控制信息，每一个后台进程也同样需要为其分配专用的存储空间，这块内存空间被称为程序全局区(Program Global Area 或Process Global Area )。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有进程都可共享 SGA，而 PGA 是非共享的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/6685fcd7d9c307b7e98d5f55.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/6685fcd7d9c307b7e98d5f55.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;PGA内部大致分三个区域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话内存：是为会话变量和会话有关信息分配的内存。&lt;/li&gt;
&lt;li&gt;SQL工作区：用于排序（Sort）哈斯连接（Hash-join）位图（Bitmap）合并和位图创建。&lt;/li&gt;
&lt;li&gt;私有 SQL 区：存储了执行SQL语句时所需的各种信息，包括绑定变量、查询执行状态、工作区域等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程结构&#34;&gt;进程结构
&lt;/h3&gt;&lt;p&gt;Oracle 的进程分为用户进程、服务器进程和后台进程。&lt;/p&gt;
&lt;p&gt;用户进程是在客户机内存上运行的程序，在用户请求连接 Oracle 数据库时建立。用户进程不能直接同 Oracle 服务器交互，而是把操作请求提交给服务进程。服务进程是在用户同 Oracle 数据库建立会话之后自动在服务器端创建的进程。服务进程直接同 Oracle 服务器交互，执行用户请求并返回结果。服务进程有专有和共享之分。&lt;/p&gt;
&lt;p&gt;后台进程属于 Oracle 实例的一部分，Oracle 的后台进程的作用是对数据进行操作，并维护数据库系统，使其始终处于良好的状态。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/668600d4d9c307b7e99308a7.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/668600d4d9c307b7e99308a7.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这里我们着重说明&lt;strong&gt;后台进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个 Oracle 实例中可以包含多种后台进程，这些进程不一定全部出现在实例中。系统中运行的后台进程数量众多，用户可以通过 &lt;code&gt;V$BGPROCESS&lt;/code&gt; 视图查询关于后台进程的信息。&lt;/p&gt;
&lt;p&gt;● 系统监控进程（SMON），主要任务是实例启动时执行恢复性工作，对有故障数据库实例进行恢复。&lt;/p&gt;
&lt;p&gt;● 进程监控进程（PMON），主要任务用于恢复失败的用户进程。&lt;/p&gt;
&lt;p&gt;● 数据库写入进程（DBWn），将修改后的数据块内容写回数据文件。&lt;/p&gt;
&lt;p&gt;● 日志写入进程（LGWR），将内存中的日志内容写入日志文件。&lt;/p&gt;
&lt;p&gt;● 检查点进程（CKPT），启动检查点，用于减少数据库实例恢复所需要的时间。&lt;/p&gt;
&lt;p&gt;● 归档进程（ARCn），当数据库服务器以归档方式运行时调用该进程完成日志归档。&lt;/p&gt;
&lt;p&gt;● 恢复进程（RECO），用于分布式数据库中的失败处理。&lt;/p&gt;
&lt;p&gt;● 锁进程（LCKn），在并行服务器模式下确保数据的一致性。&lt;/p&gt;
&lt;p&gt;● 调度进程（Dnnn），负责把用户进程分配到可用的服务进程进行处理。&lt;/p&gt;
&lt;h4 id=&#34;lgwr日志写入进程log-writer&#34;&gt;LGWR日志写入进程（Log Writer）
&lt;/h4&gt;&lt;p&gt;LGWR 日志写入进程负责将重做日志缓冲区的日志条目写入磁盘上的联机日志文件。上文的重做日志缓冲区满了之后，就是这个进程帮助写入磁盘。&lt;/p&gt;
&lt;p&gt;在出现以下情况时 LGWR 会开始工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 DWBR 进程将脏缓冲区写入数据文件之前。//预写协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在重做日志记录达到缓冲区的三分之一。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志缓冲区记录的日志多于 1M。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每隔 3 秒钟。//重做日志缓冲区是循环使用的，要腾出足够的空间给新的记录使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提交事务（执行 Commit）。//提交事务相当于确定保存修改，不存入日志文件就有丢失的可能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Oracle 总是先记载数据变化到重做日志缓冲区，然后才修改数据高速缓存。与之类似，在后台进程 DBWn 将脏缓冲区写入到数据文件之前，首先要由后台进程 LGWR 将重做日志缓冲区写入到重做日志中。与数据高速缓存相比，重做日志缓冲区相对要小得多，但写入频率高的多。&lt;/p&gt;
&lt;p&gt;Oracle 采用了快速提交机制，当执行 COMMIT 操作时，并不是将“脏缓冲区”数据写入到数据文件中，而是将重做日志缓冲区的内容写入到重做日志文件中，以确保数据库完整性。&lt;/p&gt;
&lt;h4 id=&#34;dbwn-数据库写入进程database-writer&#34;&gt;DBWn 数据库写入进程（Database Writer）
&lt;/h4&gt;&lt;p&gt;数据库写入进程负责将数据库高速缓冲区（脏缓冲区）的内容写入到数据文件。&lt;/p&gt;
&lt;p&gt;可以配置额外的进程（DBW0-DBW9，最多 10 个进程），以提高写入性能，通过设置初始化参数DB_WRITER_PROCESSES 来完成。&lt;/p&gt;
&lt;p&gt;在出现以下情况时 DBWn 进程会开始工作：&lt;/p&gt;
&lt;p&gt;● 系统发出检查点指令。//同步数据，详见检查点进程（CKPT）。&lt;/p&gt;
&lt;p&gt;● 脏缓冲区个数达到指定阀值。&lt;/p&gt;
&lt;p&gt;● 服务进程搜索一定数目的数据块后，不能找到自由缓冲区。&lt;/p&gt;
&lt;p&gt;● 数据写入计时时间到。&lt;/p&gt;
&lt;p&gt;//客户端执行 SELECT\INSERT\UPDATE\DELETE 语句时，都需要访问数据库高速缓冲区。如果是第一次访问，必须要将数据由数据文件读取到数据库高速缓冲区，所以 Oracle 必须要确保数据高速缓存总是存在足够的“自由缓冲区”以容纳新数据。当 DBWn 进程将脏缓冲区的数据块写入到数据文件后，Oracle 将把“脏缓冲区”标记为“自由缓冲区”。因此，为了保证有足够“自由缓冲区”来存放新的数据块，需要 DBWn 进程工作。&lt;/p&gt;
&lt;p&gt;● 表空间脱机或进入只读状态。&lt;/p&gt;
&lt;p&gt;● 执行删除或截断表操作。&lt;/p&gt;
&lt;p&gt;● 执行 ALTER TABLESPACE … BEGIN BACKUP 命令//需要同步数据，原理同检查点。&lt;/p&gt;
&lt;h4 id=&#34;ckpt-检查点进程checkpoint&#34;&gt;CKPT 检查点进程（Checkpoint）
&lt;/h4&gt;&lt;p&gt;CKPT 检查点进程的作用是执行一个“检查点”，同步数据库的所有数据文件、控制文件和重做日志文件。&lt;/p&gt;
&lt;p&gt;当执行检查点时，系统促使 DBWn 将数据缓冲区中数据的变化写入数据文件，同时完成对数据文件和控制文件的更新，记录下当前数据库的结构和状态。在执行一个检查点之后，数据库处于一个完整状态。在数据库发生崩溃后，可以将数据库恢复到上一个检查点。&lt;/p&gt;
&lt;p&gt;进程 CKPT 在以下情况下会开始工作：&lt;/p&gt;
&lt;p&gt;● 发生日志切换。&lt;/p&gt;
&lt;p&gt;● 关闭实例(SHUTDOWN ABORT 除外)。&lt;/p&gt;
&lt;p&gt;● 手工执行检查点操作。&lt;/p&gt;
&lt;p&gt;● 由初始化参数 LOG_CHECKPOINT_INTERVAL 和LOG_CHECKPOINT_TIMEOUT 强制发出。&lt;/p&gt;
&lt;h4 id=&#34;初始进程过程&#34;&gt;初始进程过程
&lt;/h4&gt;&lt;p&gt;现在我们已经讲完了Oracle最最重要的几个进程，可以采用一个数据写入的例子加深一下理解。&lt;/p&gt;
&lt;p&gt;假设现在有一张员工工资表，员工号 7899 的员工张三工资为 8000，现在为其加薪到 10000。&lt;/p&gt;
&lt;p&gt;1&amp;gt; 此时，第一次读取，需要将数据从数据文件读入数据库高速缓冲区。&lt;/p&gt;
&lt;p&gt;2&amp;gt; 数据读入数据库高速缓冲区后，我们修改数据的条目先记录入重做日志缓冲区。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/6686043fd9c307b7e99995e3.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/6686043fd9c307b7e99995e3.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3&amp;gt; 接着新数据被写入数据库高速缓冲区&lt;/p&gt;
&lt;p&gt;4&amp;gt; 提交，LGWR 进程将条目从重做日志缓冲区写入联机重做日志文件&lt;/p&gt;
&lt;p&gt;5&amp;gt; 执行检查点 CKPT，同步数据库。发现联机日志文件为最新，同步更新数据文件、控制文件，触发了 DBWn 进程。此时数据才发生了真正的改变。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/6686043fd9c307b7e99995fe.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/6686043fd9c307b7e99995fe.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;smon-系统监控进程system-monitor&#34;&gt;SMON 系统监控进程（System Monitor）
&lt;/h4&gt;&lt;p&gt;SMON 系统监控进程主要作用是强制对数据库进行恢复操作。&lt;/p&gt;
&lt;p&gt;在实例启动时，如果上一次数据库是非正常关闭，并且重做日志文件和控制文件的 SCN 值是不同的，Oracle 将自动在重新打开数据库之前，通过执行重做日志文件的记录，来同步所有数据文件、控制文件和重做日志文件，确保所有数据库文件的一致性，然后才打开数据库。&lt;/p&gt;
&lt;p&gt;该进程还负责在启动实例时清理临时段和合并区（Extent）碎片等工作。&lt;/p&gt;
&lt;p&gt;所以 SMON进程的工作归纳如下：&lt;/p&gt;
&lt;p&gt;● 进行实例恢复&lt;/p&gt;
&lt;p&gt;● 合并数据文件的自由空间&lt;/p&gt;
&lt;p&gt;● 释放数据文件的临时段&lt;/p&gt;
&lt;h4 id=&#34;pmon-进程监控进程process-monitor&#34;&gt;PMON 进程监控进程（Process Monitor）
&lt;/h4&gt;&lt;p&gt;PMON 进程监控进程负责对失败的用户进程或服务进程进行恢复。&lt;/p&gt;
&lt;p&gt;当用户进程连接到Oracle 服务器时，Oracle 将在服务器端分配相应的服务进程。这时由 PMON 进程来监视用户进程的执行情况。当由于种种原因，用户对 Oracle 数据库的连接，发生崩溃、挂起或异常终止现象时，该进程负责清除服务进程所占用的资源，回滚没有完成的事务。&lt;/p&gt;
&lt;p&gt;当 PMON 检测到用户进程失败时，进行的工作归纳如下：&lt;/p&gt;
&lt;p&gt;● 回滚当前用户的事务&lt;/p&gt;
&lt;p&gt;● 释放当前用户加的表或行级锁&lt;/p&gt;
&lt;p&gt;● 释放用户的其他资源&lt;/p&gt;
&lt;p&gt;● 重新启动死掉的调度进程&lt;/p&gt;
&lt;h4 id=&#34;sql语句在rdbms是如何运作的&#34;&gt;SQL语句在RDBMS是如何运作的
&lt;/h4&gt;&lt;p&gt;以上五个进程，是Oracle中必须的五个进程，相信现在已经有了一定的了解，现在我们完整梳理下SQL语句在RDBMS是如何运作的。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/66860d0ad9c307b7e9a72c9c.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/66860d0ad9c307b7e9a72c9c.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;1.将SQL语句加载入数据库缓冲区
2.将SQL语句要操作的数据文件副本加载入数据库缓冲区
3.执行SQL语句，修改数据文件副本，形成“脏缓冲区”
4.CKPT检测到“脏缓冲区”，调用DBWn
5.在DBWn运行之前，先运行了LGWR，将数据文件的原始状态和数据库的改变记录到Redo Log Files
6.运行DBWn，将“脏缓冲区的内容写入到数据文件”
7.同时CKPT修改控制文件和数据文件头
8.SMON回收不必要的空闲资源&lt;/p&gt;
&lt;h4 id=&#34;arcn-归档进程archive&#34;&gt;ARCn 归档进程（Archive）
&lt;/h4&gt;&lt;p&gt;ARCn 归档进程完成日志的归档备份，是一个可选后台进程，但是也十分重要。&lt;/p&gt;
&lt;p&gt;当数据库运行于归档日志模式（ARCHIVELOG）下时，负责将已写满的&lt;strong&gt;重做日志文件&lt;/strong&gt;复制到&lt;strong&gt;归档日志&lt;/strong&gt;目标文件中，这样可以保留所有的重做记录。&lt;/p&gt;
&lt;h4 id=&#34;reco-恢复进程recover&#34;&gt;&lt;strong&gt;RECO&lt;/strong&gt; 恢复进程（Recover）
&lt;/h4&gt;&lt;p&gt;RECO 恢复进程负责在分布式数据库（Distributed Database）环境下,自动恢复失败的分布式事务。当某个分布式事务由于网络连接故障或者其他原因失败时，RECO 进程将会尝试与该事物相关的所有数据库进行联系，已完成对失败事物的处理工作。&lt;/p&gt;
&lt;h4 id=&#34;dnnnn-调度进程&#34;&gt;Dnnnn 调度进程
&lt;/h4&gt;&lt;p&gt;Dnnnn 调度进程是多线程服务器体系结构的一部分，调度进程接受用户进程的请求，将他们放入到请求队列中，然后为请求队列中的用户进程分配一个服务进程。&lt;/p&gt;
&lt;h3 id=&#34;oracle-数据库&#34;&gt;Oracle 数据库
&lt;/h3&gt;&lt;p&gt;数据库是数据存储的容器，作用是用来收集、存储数据和返回信息。&lt;/p&gt;
&lt;p&gt;Oracle 数据库的物理结构包括两个部分，分别是&lt;strong&gt;数据库文件&lt;/strong&gt;（控制+数据+重做日志）和&lt;strong&gt;操作系统文件&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;控制文件control-files&#34;&gt;控制文件（Control Files）
&lt;/h4&gt;&lt;p&gt;控制文件是一个很小的&lt;strong&gt;二进制文件&lt;/strong&gt;，用于记录和维护数据库结构（数据库名、数据文件的名称和路径、联机重做日志文件的名称和路径、备份信息等），每个 Oracle 数据库可以有1-8 个控制文件，最少要包含一个控制文件。&lt;/p&gt;
&lt;h4 id=&#34;数据文件data-file&#34;&gt;数据文件（Data File）
&lt;/h4&gt;&lt;p&gt;数据文件是用于存储数据库数据的物理文件，它由若干个操作系统文件组成，在数据文件中存储着用户数据(表、索引等)、数据字典以及回滚段数据等。&lt;/p&gt;
&lt;p&gt;没错，这才是我们一般意义理解上的“数据库”。&lt;/p&gt;
&lt;h4 id=&#34;联机重做日志文件online-redo-log-file&#34;&gt;联机重做日志文件（Online Redo Log File）
&lt;/h4&gt;&lt;p&gt;我们知道重做日志缓冲区是循环使用的：当重做日志缓冲区的重做项被写入联机重做日志文件后，重做日志缓冲区的内容可以被覆盖。&lt;/p&gt;
&lt;p&gt;日志文件也是循环使用的，当联机重做日志文件中记录的数据已经同步写入数据文件，联机重做日志文件中的内容也可以被覆盖。但是这种循环以组的方式循环。&lt;/p&gt;
&lt;h4 id=&#34;操作系统文件&#34;&gt;操作系统文件
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化参数文件（Initialization Parameter File）&lt;/strong&gt;：定义了 Oracle 实例的各项参数，初始化参数文件一般默认存放在$ORACLE_HOME/dbs路径下。&lt;/p&gt;
&lt;p&gt;初始化参数文件分为静态初始化参数文件和动态初始化参数文件。静态初始化参数文件为文本格式，可以用 vi 编辑器编辑，默认名为 initsid.ora；动态初始化参数文件为二进制格式，不可以用 vi 编辑器编辑，默认名为 spfilesid.ora&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;口令文件（Password File）&lt;/strong&gt;：存放&lt;strong&gt;特权用户&lt;/strong&gt;信息及其口令。“特权用户”是指具有启动、关闭Oracle 服务器并建立数据库等特殊权利的用户。如具有 SYSDBA、SYSOPER、SYSASM权限的用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;归档日志文件（Archive Log File）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归档日志文件用于记录联机重做日志文件中的内容。&lt;/p&gt;
&lt;p&gt;我们知道，联机重做日志文件以日志组的形式存在，并且循环使用。也就是说，如果联机重做日志文件被覆盖以后数据库发生故障，由于日志已经覆盖，将会导致数据库无法恢复。&lt;/p&gt;
&lt;p&gt;我们把联机重做日志以脱机的形式存放在归档日志文件里，既可以保证日志不会丢失，又可以保证不影响数据库的正常运行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;追踪文件（Trace File）和警告文件（Alert Log File）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追踪文件用于存放后台进程和服务器进程的跟踪信息。每个后台进程都有相应的跟踪文件，存放着后台进程的警告和错误信息。服务器进程跟踪文件用于存放 SQL 语句的跟踪信息，该类文件会记载 SQL 语句的执行时间、执行计划等信息等。&lt;/p&gt;
&lt;p&gt;警告文件由连续的消息和错误组成。通过查看警告文件，可以查看到 Oracle 内部错误、块损坏错误以及非默认的初始化参数值，并且可以监视特权用户的所有操作，例如启动、关闭数据库。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
